# Q1:  Big O Notation in Algorithm Analysis

Big O notation describes the upper bound of an algorithm's time complexity. It helps us understand how an algorithm scales and performs as the input grows.

# Examples & Key Rules 

**1. Constant Time Operations.**
    Accessing an element in an array takes the same time, without the size of array mattering.No matter how large the  array is, accessing one element is always O(1)

   ** Example:**
  int getElement(int arr[], int index) {
    return arr[index]; 
}


**2. Ignore constants**
Coefficients and lower order terms don’t matter because they have little effect on large inputs.


   ** Example:**
     If an algorithm takes O(2n), we simplify it to O(n).
     If an algorithm runs in O(n + 5), we simplify it to O(n).
**3. Focus on a dominant term **
   > 
   > Example:
    In linear search, even though the best case might be O(1) when the element is at the beginning, the worst-case time complexity is `O(n)`when the element is not found or is at the end.

4. Comparison of Algorithms:
   > By focusing on the dominating term and ignoring constants, Big O provides a common ground to compare different algorithms.
   > Example:
    An algorithm running in `O(n log n)` is generally more efficient than one running in `O(n²)` for large values of `n`.

5. Simplification and Focus on Asymptotic Behavior:
   > Big O notation simplifies the comparison of algorithm efficiencies by focusing on how performance scales with input size, rather than precise operation counts.
   > This abstraction helps in understanding algorithm performance regardless of hardware or implementation differences.


